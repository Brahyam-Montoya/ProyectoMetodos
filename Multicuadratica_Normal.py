# -*- coding: utf-8 -*-
"""Proyecto2.0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10Qr1mPzsxgh17KXAKUJUteeS96vTIiM0

Multicuadratica normal
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D


def f(x, y):
    try:
        return round(x * y + 1 / (2 * x) + 1 / (2 * y), 3)
    except ZeroDivisionError:
        return None

def obtenerMatrizPuntos(x_vals, y_vals):
    matriz = []
    for y in y_vals:
        fila = []
        for x in x_vals:
            fila.append((x, y))
        matriz.append(fila)
    return matriz

def matrizResultados(puntos_matriz):
    matriz = []
    for fila in puntos_matriz:
        matriz.append([f(x, y) for (x, y) in fila])
    return matriz

def calcular_distancia(p1, p2):
    # return np.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)
    return np.linalg.norm(np.array(p1) - np.array(p2))

def psi_multicuadrica(r, c=1):
    return np.sqrt(r**2 + c**2)

def coeficientes(A, b):
    return np.linalg.solve(A, b)

# def interpolar(x_eval, y_eval, puntos, coef):
#     suma = 0
#     for i, (x_i, y_i) in enumerate(puntos):
#         r = calcular_distancia((x_eval, y_eval), (x_i, y_i))
#         phi = psi_multicuadrica(r)
#         suma += coef[i] * phi
#     return suma

def interpolar(x, y, puntos, coeficientes, c=1):
    return sum(coeficientes[j] * psi_multicuadrica(calcular_distancia((x, y), puntos[j]), c) for j in range(len(puntos)))


# --- Datos de entrada
x = [-3, -1.5, 0.01, 1.5,  3]
y = [-1,0.75, 2.5, 4.25,  6]

# ---------------------------------------------- Matriz de puntos ------------------------------------------------
puntos_matriz = obtenerMatrizPuntos(x, y)
print("\nMatriz de coordenadas (x, y):")
for fila in puntos_matriz:
    print(fila)

# ------------------------------------------- Matriz de resultados f(x, y) --------------------------------------
valores_f = matrizResultados(puntos_matriz)
print("\nMatriz de resultados f(x, y):")
for fila in valores_f:
    print(fila)

# ------------------------------------------- Matriz de distancias -----------------------------------------------
puntos = [p for fila in puntos_matriz for p in fila]
n = len(puntos)
R = np.zeros((n, n))
for i in range(n):
    for j in range(n):
        R[i][j] = calcular_distancia(puntos[i], puntos[j])

np.set_printoptions(precision=4, suppress=True)
print("\nMatriz de distancias R:")
print(R)

# ---------------------------------------- Aplicar función radial ------------------------------------------------
A = psi_multicuadrica(R)
print("\nMatriz A luego de aplicar función radial:")
print(A)

# --------------------------------------- Vector de resultados b (aplanado) --------------------------------------
b = np.array([f(x, y) for (x, y) in puntos])
print("\nVector de resultados b:")
print(b)

# ------------------------------------------------ Resolver sistema ----------------------------------------------
c = coeficientes(A, b)
print("\nVector de coeficientes c:")
print(c)

# ------------------------------------------ Interpolación en un nuevo punto ------------------------------------
x_eval, y_eval = 0, 2.5
resultado = interpolar(x_eval, y_eval, puntos, c)
print(f"\nResultado de interpolar en ({x_eval}, {y_eval}): {resultado:.4f}")

# ----------------------------------------- Graficar la superficie interpolada --------------------------------
x_vals = np.linspace(min(x), max(x), 100)
y_vals = np.linspace(min(y), max(y), 100)
X, Y = np.meshgrid(x_vals, y_vals)
Z = np.array([[interpolar(xi, yi, puntos, c) for xi in x_vals] for yi in y_vals])

fig = plt.figure(figsize=(10, 7))
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(X, Y, Z, cmap='viridis', alpha=0.9, edgecolor='none')

for (xi, yi), fi in zip(puntos, b):
    ax.scatter(xi, yi, fi, color='red')

ax.set_title("Superficie Interpolada - Función Radial Multicuádrica")
ax.set_xlabel("x")
ax.set_ylabel("y")
ax.set_zlabel("f(x, y)")
plt.tight_layout()
# plt.savefig("superficie_interpolada_5x5.png", dpi=300)